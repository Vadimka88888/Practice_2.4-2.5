## Practice_2.4-2.5

# Вариант 15
# 1. Реализация на трёх языках программирования
   Коды в файле Code
# 2. Подробное описание алгоритма

Шаг 1: Инициализация

· Создаём лабиринт 5×5, где:
  · 0 - проходимая клетка
  · 1 - стена (непроходимая клетка)
· Инициализируем матрицу посещений visited размером 5×5
· Начинаем с начальной точки (0, 0)

Шаг 2: Рекурсивная функция backtrack

Функция принимает:

· Текущие координаты (x, y)
· Текущий путь path
· Матрицу посещений visited

Шаг 3: Проверка завершения

· Если текущая позиция (4, 4) (конечная точка):
  · Сохраняем текущий путь в список всех путей
  · Возвращаемся на предыдущий уровень рекурсии

Шаг 4: Генерация возможных ходов

Для текущей позиции проверяем 4 направления:

· Вправо: (x, y+1)
· Вниз: (x+1, y)
· Влево: (x, y-1)
· Вверх: (x-1, y)

Шаг 5: Проверка валидности хода

Новая позиция считается валидной если:

1. Находится в границах лабиринта (0-4 по обеим осям)
2. Ячейка свободна (значение 0)
3. Ячейка не посещена в текущем пути

Шаг 6: Рекурсивный вызов

Для каждого валидного хода:

· Помечаем ячейку как посещённую
· Добавляем ячейку в текущий путь
· Вызываем backtrack рекурсивно для новой позиции

Шаг 7: Backtrack (откат)

После возвращения из рекурсивного вызова:

· Удаляем ячейку из текущего пути
· Снимаем пометку посещения

Шаг 8: Завершение

Когда все возможные пути исследованы, возвращаем список всех найденных путей

# 3. Оценка временной сложности

Временная сложность: O(4^(N×M))

Где:

· N = 5 (высота лабиринта)
· M = 5 (ширина лабиринта)
· 4 - количество возможных направлений движения из каждой клетки

# 4. Объяснение сложности

Почему экспоненциальная сложность?

1. Ветвление: Из каждой свободной клетки мы можем двигаться в до 4 направлений
2. Глубина рекурсии: Максимальная длина пути может достигать N×M = 25 шагов
3. Комбинаторный взрыв: Количество возможных путей растёт экспоненциально с размером лабиринта

Уточнения:

· В худшем случае (лабиринт без стен): O(4^(N×M)) = O(4^25) ≈ 1.1×10¹⁵ операций
· На практике: Наличие стен значительно сокращает количество возможных путей
· Фактическая сложность: Зависит от структуры лабиринта

Оптимизации:

1. Посещённые клетки: Матрица visited предотвращает зацикливание
2. Backtracking: Откат неэффективных путей сокращает перебор
3. Граничные условия: Проверка границ лабиринта

# 5. Тестирование на трёх языках
