## Practice_2.4-2.5

# Вариант 15
# 1. Реализация на трёх языках программирования
   Напишите программу для генерации всех путей в лабиринте размером 5×5
# 2. Подробное описание алгоритма

Шаг 1: Инициализация

· Создаём лабиринт 5×5, где:
  · 0 - проходимая клетка
  · 1 - стена (непроходимая клетка)
· Инициализируем матрицу посещений visited размером 5×5
· Начинаем с начальной точки (0, 0)

Шаг 2: Рекурсивная функция backtrack

Функция принимает:

· Текущие координаты (x, y)
· Текущий путь path
· Матрицу посещений visited

Шаг 3: Проверка завершения

· Если текущая позиция (4, 4) (конечная точка):
  · Сохраняем текущий путь в список всех путей
  · Возвращаемся на предыдущий уровень рекурсии

Шаг 4: Генерация возможных ходов

Для текущей позиции проверяем 4 направления:

· Вправо: (x, y+1)
· Вниз: (x+1, y)
· Влево: (x, y-1)
· Вверх: (x-1, y)

Шаг 5: Проверка валидности хода

Новая позиция считается валидной если:

1. Находится в границах лабиринта (0-4 по обеим осям)
2. Ячейка свободна (значение 0)
3. Ячейка не посещена в текущем пути

Шаг 6: Рекурсивный вызов

Для каждого валидного хода:

· Помечаем ячейку как посещённую
· Добавляем ячейку в текущий путь
· Вызываем backtrack рекурсивно для новой позиции

Шаг 7: Backtrack (откат)

После возвращения из рекурсивного вызова:

· Удаляем ячейку из текущего пути
· Снимаем пометку посещения

Шаг 8: Завершение

Когда все возможные пути исследованы, возвращаем список всех найденных путей

# 3. Оценка временной сложности

Временная сложность: O(4^(N×M))

Где:

· N = 5 (высота лабиринта)
· M = 5 (ширина лабиринта)
· 4 - количество возможных направлений движения из каждой клетки

# 4. Объяснение сложности

Почему экспоненциальная сложность?

1. Ветвление: Из каждой свободной клетки мы можем двигаться в до 4 направлений
2. Глубина рекурсии: Максимальная длина пути может достигать N×M = 25 шагов
3. Комбинаторный взрыв: Количество возможных путей растёт экспоненциально с размером лабиринта

Уточнения:

· В худшем случае (лабиринт без стен): O(4^(N×M)) = O(4^25) ≈ 1.1×10¹⁵ операций
· На практике: Наличие стен значительно сокращает количество возможных путей
· Фактическая сложность: Зависит от структуры лабиринта

Оптимизации:

1. Посещённые клетки: Матрица visited предотвращает зацикливание
2. Backtracking: Откат неэффективных путей сокращает перебор
3. Граничные условия: Проверка границ лабиринта

# 5. Тестирование на трёх языках
Python:
0 1 0 0 0
0 0 0 1 0
1 0 1 0 0
0 0 0 0 1
0 1 0 0 0
Вывод: 
Найдено путей: 4

Путь 1 (длина: 13):
(0,0) -> (1,0) -> (1,1) -> (1,2) -> (0,2) -> (0,3) -> (0,4) -> (1,4) -> (2,4) -> (2,3) -> (3,3) -> (4,3) -> (4,4)

Путь 2 (длина: 15):
(0,0) -> (1,0) -> (1,1) -> (1,2) -> (0,2) -> (0,3) -> (0,4) -> (1,4) -> (2,4) -> (2,3) -> (3,3) -> (3,2) -> (4,2) -> (4,3) -> (4,4)

Путь 3 (длина: 9):
(0,0) -> (1,0) -> (1,1) -> (2,1) -> (3,1) -> (3,2) -> (3,3) -> (4,3) -> (4,4)

Путь 4 (длина: 9):
(0,0) -> (1,0) -> (1,1) -> (2,1) -> (3,1) -> (3,2) -> (4,2) -> (4,3) -> (4,4)

C++:
0 1 0 0 0
0 0 0 1 0
1 0 1 0 0
0 0 0 0 1
0 1 0 0 0

Вывод: 
Найдено путей: 4

Путь 1 (длина: 9):
(0,0) -> (1,0) -> (1,1) -> (2,1) -> (3,1) -> (3,2) -> (4,2) -> (4,3) -> (4,4)

Путь 2 (длина: 9):
(0,0) -> (1,0) -> (1,1) -> (2,1) -> (3,1) -> (3,2) -> (3,3) -> (4,3) -> (4,4)

Путь 3 (длина: 13):
(0,0) -> (1,0) -> (1,1) -> (1,2) -> (0,2) -> (0,3) -> (0,4) -> (1,4) -> (2,4) -> (2,3) -> (3,3) -> (4,3) -> (4,4)

Путь 4 (длина: 15):
(0,0) -> (1,0) -> (1,1) -> (1,2) -> (0,2) -> (0,3) -> (0,4) -> (1,4) -> (2,4) -> (2,3) -> (3,3) -> (3,2) -> (4,2) -> (4,3) -> (4,4)

Java:
. . # . . 
. # . . . 
. . . # . 
# # . . . 
. . . # . 
Вывод: 

Найдено путей: 3

Путь 1 (длина: 9):
(0,0) -> (1,0) -> (2,0) -> (2,1) -> (2,2) -> (3,2) -> (3,3) -> (3,4) -> (4,4)

Путь 2 (длина: 11):
(0,0) -> (1,0) -> (2,0) -> (2,1) -> (2,2) -> (1,2) -> (1,3) -> (1,4) -> (2,4) -> (3,4) -> (4,4)

Путь 3 (длина: 13):
(0,0) -> (1,0) -> (2,0) -> (2,1) -> (2,2) -> (1,2) -> (1,3) -> (0,3) -> (0,4) -> (1,4) -> (2,4) -> (3,4) -> (4,4)
# 6. Вопрос 6
Суть алгоритма Backtracking

Backtracking (возврат, обратный ход) — это метод решения задач перебора, который систематически проверяет все возможные варианты решения, но с "откатом" при обнаружении тупиковой ветви.

Основная идея:

1. Пошаговое построение решения — алгоритм постепенно строит кандидата в решения
2. Проверка на каждом шаге — после каждого выбора проверяется, может ли текущий путь привести к решению
3. Откат при неудаче — если текущий выбор заводит в тупик, алгоритм возвращается назад и пробует другой вариант
